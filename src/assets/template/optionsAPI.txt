<template>
  <div class="p-0 mt-4">
    <div class="panel-switch-buttons mt-4">
      <span>
        <v-btn
          data-testid="btn-panel-switch-next"
          block
          class="mb-3 sm:mb-0"
          depressed
          color="primary"
          :disabled="nextBtnDisabled"
          :loading="nextBtnLoading || nextLoading"
          tabindex="1"
          large
          @click="nextClickMethod"
        >
          {{ localNextStepBtnTitle }}
          <v-icon v-if="!hideNextChevron" right>chevron_right</v-icon>
        </v-btn>
      </span>
      <span v-if="showBackButton">
        <v-btn
          depressed
          block
          large
          class="md:mr-4 mt-3"
          color="gray"
          tabindex="2"
          :disabled="nextBtnLoading || nextLoading"
          @click="prevClickMethod"
        >
          <v-icon left>chevron_left</v-icon>
          {{ previousBtnTitle }}
        </v-btn>
      </span>
    </div>

    <v-alert v-if="error" class="my-3" text color="error">
      <span v-html="error" />
    </v-alert>
  </div>
</template>

<script>
import { useGlobalStore, mapState } from '@/stores'

export default {
  name: 'PanelSwitchButtons',

  props: {
    nextBtnText: {
      type: String,
      default: '',
    },
    nextBtnLoading: Boolean,
    nextBtnDisabled: Boolean,
    hidePrev: Boolean,
    hideNextChevron: Boolean,
  },

  data() {
    return {
      dupItem: true,
      nextLoading: false,
      error: null,
      selectedConfig: false,
      insertionType: true
    }
  },

  computed: {
    ...mapState(useGlobalStore, [
      'prevPanel',
      'previousBtnTitle',
      'getAppConfig',
      'hidePrevBtn',
      'nextStepBtnTitle',
      'apConfigBtnText',
    ]),
    // arrowComputed: () => {
    //   return this.prop
    // },
    // ^ this computed property should error. 
    localNextStepBtnTitle() {
      return this.apConfigBtnText || this.nextBtnText || this.nextStepBtnTitle
    },
    localHidePrevBtn() {
      if (this.hidePrev === true) {
        return true
      } else return this.hidePrevBtn
    },
    showBackButton() {
      if (this.hidePrev) return this.prevPanel
      return (
        this.getAppConfig.enable_back_button &&
        !this.localHidePrevBtn &&
        !this.prevPanel?.toLowerCase().startsWith('auth')
      )
    },
  },
  mounted() {
    this.error = null
  },
  mixins: ["something"],
  methods: {
        ...mapActions(useGlobalStore, [
      'doMoreTHINGS',
    ]),
    //arrowTest: () => { 
    //  console.log()
    //},
    // ^ this arrow function will throw a error and needs to be converted first. 
    // scopeTest(dupItem) {
    //  const ok = this.dupItem
    //  console.log(dupItem)
    //  this function should error and wont be able to be converted
    // },
    async nextClickMethod() {
      const innerArrow = () => 'someValue'
      this.doMoreTHINGS()
      this.$refs.something.lotsOfThings = true
      this.error = null
      this.nextLoading = true
      this.$refs.anotherRef.values = true
      this.$emit('another-object', this.error)
      this.$emit('a-event', { ok: true })
      this.$emit('next')
      this.$emit('set-config', {
        config: this.selectedConfig,
        insertionType: this.insertionType,
      })
    },
    async prevClickMethod(someValue) {
      this.$nextTick(() => {
        nextClickMethod()
      })
      this.error = null
      this.$emit('previous')
    },
  },
  watch: {
    getAppConfig(dupItem, oldVal) {
      this.$emit('watch-emitter')
      this.$emit('second-watch')
      // const b = this._dupItem
      // this._dupItem = oldVal
    }
  }
}
</script>
